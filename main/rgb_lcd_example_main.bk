/*
 * SPDX-FileCopyrightText: 2022 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: CC0-1.0
 */

#include <stdio.h>
#include "sdkconfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_timer.h"
#include "esp_lcd_panel_ops.h"
#include "esp_lcd_panel_rgb.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "esp_log.h"
#include "lvgl.h"

#include "driver/gpio.h"

#include "driver/i2c.h"

#include "lcd_dev.h"


#define I2C_MASTER_SCL_IO           8      /*!< GPIO number used for I2C master clock */
#define I2C_MASTER_SDA_IO           18      /*!< GPIO number used for I2C master data  */
#define I2C_MASTER_NUM              0                          /*!< I2C master i2c port number, the number of i2c peripheral interfaces available will depend on the chip */
#define I2C_MASTER_FREQ_HZ          50000                     /*!< I2C master clock frequency */
#define I2C_MASTER_TX_BUF_DISABLE   0                          /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0                          /*!< I2C master doesn't need buffer */
#define I2C_MASTER_TIMEOUT_MS       1000

#define ESP_SLAVE_ADDR 0x38




#define ACK_CHECK_EN 0x1           /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS 0x0          /*!< I2C master will not check ack from slave */
#define ACK_VAL 0x0                /*!< I2C ack value */
#define NACK_VAL 0x1               /*!< I2C nack value */

#define WRITE_BIT 0 /*!< I2C master write */
#define READ_BIT 1   /*!< I2C master read */



#define FT_DEVIDE_MODE 			0x00   		
#define FT_REG_NUM_FINGER       0x02		

#define FT_TP1_REG 				0X03	  	
#define FT_TP2_REG 				0X09		
#define FT_TP3_REG 				0X0F		
#define FT_TP4_REG 				0X15		
#define FT_TP5_REG 				0X1B		
 

#define	FT_ID_G_LIB_VERSION		0xA1		
#define FT_ID_G_MODE 			0xA4   		
#define FT_ID_G_THGROUP			0x80   		
#define FT_ID_G_PERIODACTIVE	0x88   		

static const char *TAG = "example";

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////// Please update the following configuration according to your LCD spec //////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define EXAMPLE_LCD_PIXEL_CLOCK_HZ     (18 * 1000 * 1000)
#define EXAMPLE_LCD_BK_LIGHT_ON_LEVEL  1
#define EXAMPLE_LCD_BK_LIGHT_OFF_LEVEL !EXAMPLE_LCD_BK_LIGHT_ON_LEVEL
#define EXAMPLE_PIN_NUM_BK_LIGHT       4
#define EXAMPLE_PIN_NUM_HSYNC          46
#define EXAMPLE_PIN_NUM_VSYNC          3
#define EXAMPLE_PIN_NUM_DE             0
#define EXAMPLE_PIN_NUM_PCLK           9
#define EXAMPLE_PIN_NUM_DATA0          14 // B0
#define EXAMPLE_PIN_NUM_DATA1          13 // B1
#define EXAMPLE_PIN_NUM_DATA2          12 // B2
#define EXAMPLE_PIN_NUM_DATA3          11 // B3
#define EXAMPLE_PIN_NUM_DATA4          10 // B4
#define EXAMPLE_PIN_NUM_DATA5          39 // G0
#define EXAMPLE_PIN_NUM_DATA6          38 // G1
#define EXAMPLE_PIN_NUM_DATA7          45 // G2
#define EXAMPLE_PIN_NUM_DATA8          48 // G3
#define EXAMPLE_PIN_NUM_DATA9          47 // G4
#define EXAMPLE_PIN_NUM_DATA10         21 // G5
#define EXAMPLE_PIN_NUM_DATA11         1  // R0
#define EXAMPLE_PIN_NUM_DATA12         2  // R1
#define EXAMPLE_PIN_NUM_DATA13         42 // R2
#define EXAMPLE_PIN_NUM_DATA14         41 // R3
#define EXAMPLE_PIN_NUM_DATA15         40 // R4
#define EXAMPLE_PIN_NUM_DISP_EN        -1

// The pixel number in horizontal and vertical
#define EXAMPLE_LCD_H_RES              480
#define EXAMPLE_LCD_V_RES              480

#define EXAMPLE_LVGL_TICK_PERIOD_MS    2


typedef struct{
    uint16_t x_pos;
    uint16_t y_pos;
    uint8_t press_state; // 0放开 1按下


}tp_data_tag;

static tp_data_tag tp_data;


// we use two semaphores to sync the VSYNC event and the LVGL task, to avoid potential tearing effect
#if CONFIG_EXAMPLE_AVOID_TEAR_EFFECT_WITH_SEM
SemaphoreHandle_t sem_vsync_end;
SemaphoreHandle_t sem_gui_ready;
#endif

extern void example_lvgl_demo_ui(lv_disp_t *disp);

static bool example_on_vsync_event(esp_lcd_panel_handle_t panel, const esp_lcd_rgb_panel_event_data_t *event_data, void *user_data)
{
    BaseType_t high_task_awoken = pdFALSE;
#if CONFIG_EXAMPLE_AVOID_TEAR_EFFECT_WITH_SEM
    if (xSemaphoreTakeFromISR(sem_gui_ready, &high_task_awoken) == pdTRUE) {
        xSemaphoreGiveFromISR(sem_vsync_end, &high_task_awoken);
    }
#endif
    return high_task_awoken == pdTRUE;
}

static void example_lvgl_flush_cb(lv_disp_drv_t *drv, const lv_area_t *area, lv_color_t *color_map)
{

    esp_lcd_panel_handle_t panel_handle = (esp_lcd_panel_handle_t) drv->user_data;
    int offsetx1 = area->x1;
    int offsetx2 = area->x2;
    int offsety1 = area->y1;
    int offsety2 = area->y2;
#if 0
    xSemaphoreGive(sem_gui_ready);
    xSemaphoreTake(sem_vsync_end, portMAX_DELAY);
#endif
    // pass the draw buffer to the driver
    esp_lcd_panel_draw_bitmap(panel_handle, offsetx1, offsety1, offsetx2 + 1, offsety2 + 1, color_map);
    lv_disp_flush_ready(drv);
}

static void example_increase_lvgl_tick(void *arg)
{
    /* Tell LVGL how many milliseconds has elapsed */
    lv_tick_inc(EXAMPLE_LVGL_TICK_PERIOD_MS);
}
esp_lcd_panel_handle_t panel_handle = NULL;

static void _task_show_rgb();
static void _task_show_by_rgb(int x_start, int y_start, int max_x, int max_y,uint8_t color_byte );
static void _test_my(int x, int len, uint8_t color_byte);
static void example_lvgl_flush_cb_new(int x_start, int y_start, int x_end, int y_end,uint8_t *img_data);
static esp_err_t i2c_master_write_slave(i2c_port_t i2c_num, uint8_t *data_wr, size_t size);
static esp_err_t i2c_master_read_slave(i2c_port_t i2c_num, uint8_t *data_rd, size_t size);


static esp_err_t i2c_register_read(uint8_t reg_addr, uint8_t *data, size_t len);

esp_err_t i2c_master_init(void);

/**
 * @brief Write a byte to a MPU9250 sensor register
 */
static esp_err_t i2c_register_write_byte(uint8_t reg_addr, uint8_t data);

static void example_lvgl_touch_cb(lv_indev_drv_t * drv, lv_indev_data_t * data)
{
    if (tp_data.press_state == 1) {
        data->point.x = tp_data.x_pos;
        data->point.y = tp_data.y_pos;
        data->state = LV_INDEV_STATE_PRESSED;
        
    } else {
        data->state = LV_INDEV_STATE_RELEASED;
       
    }
}

uint8_t *img_buf = NULL;
#define PIX_NUM   480*480*2  
static void _lvgl_init(lv_disp_draw_buf_t* disp_buf, lv_disp_drv_t* disp_drv ){

    
    lv_init();
    img_buf = malloc(PIX_NUM);
    //lv_disp_draw_buf_init(&disp_buf, buf1, buf2, EXAMPLE_LCD_H_RES * EXAMPLE_LCD_V_RES);
    lv_disp_draw_buf_init(disp_buf, img_buf, NULL, EXAMPLE_LCD_H_RES * EXAMPLE_LCD_V_RES);


    lv_disp_drv_init(disp_drv);
    disp_drv->hor_res = EXAMPLE_LCD_H_RES;
    disp_drv->ver_res = EXAMPLE_LCD_V_RES;
    disp_drv->flush_cb = example_lvgl_flush_cb;
    disp_drv->draw_buf = disp_buf;
    disp_drv->user_data = panel_handle;

    lv_disp_t *disp = lv_disp_drv_register(disp_drv);

 
//tp

    static lv_indev_drv_t indev_drv;    // Input device driver (Touch)
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.disp = disp;
    indev_drv.read_cb = example_lvgl_touch_cb;
    indev_drv.user_data = NULL;

    lv_indev_drv_register(&indev_drv);

#if 1
    // Tick interface for LVGL (using esp_timer to generate 2ms periodic event)
    const esp_timer_create_args_t lvgl_tick_timer_args = {
        .callback = &example_increase_lvgl_tick,
        .name = "lvgl_tick"
    };
    esp_timer_handle_t lvgl_tick_timer = NULL;
    ESP_ERROR_CHECK(esp_timer_create(&lvgl_tick_timer_args, &lvgl_tick_timer));
    ESP_ERROR_CHECK(esp_timer_start_periodic(lvgl_tick_timer, EXAMPLE_LVGL_TICK_PERIOD_MS * 1000));
#endif

    
    //刷新屏幕
    _task_show_by_rgb(0, 0, 480,480, 0xff);
    example_lvgl_demo_ui(disp);
    return ;
}

//扫描
static void _scan_tp(){
    uint16_t x_pos = 0;
    uint16_t y_pos = 0;
    uint8_t read_buf[8] = {0};
    i2c_register_read(FT_REG_NUM_FINGER, read_buf, 1);
    if(read_buf[0] == 1){
        i2c_register_read(FT_TP1_REG, read_buf, 4);
        if((read_buf[0]&0X80)!=0X80) return;
        x_pos=((uint16_t)(read_buf[0]&0X0F)<<8)+read_buf[1];
        y_pos=((uint16_t)(read_buf[2]&0X0F)<<8)+read_buf[3];
        
        tp_data.x_pos = x_pos;
        tp_data.y_pos = y_pos;
        tp_data.press_state = 1;
    }else{
        tp_data.x_pos = 0;
        tp_data.y_pos = 0;
        tp_data.press_state = 0;

    }


    return ;
}


static void _tp_5206_init(){
    uint8_t data_rx[8] = {0};
    uint8_t data_wr[8] = {0};

    esp_err_t err;
  

    ESP_ERROR_CHECK(i2c_register_write_byte(FT_DEVIDE_MODE, 0));

    //FT_ID_G_MODE
    ESP_ERROR_CHECK(i2c_register_write_byte(FT_ID_G_MODE, 0));

    ESP_ERROR_CHECK(i2c_register_write_byte(FT_ID_G_THGROUP,28));

    ESP_ERROR_CHECK(i2c_register_write_byte(FT_ID_G_PERIODACTIVE,12));

    ESP_ERROR_CHECK(i2c_register_read(FT_ID_G_LIB_VERSION, data_rx, 2));

    printf("FT_ID_G_LIB_VERSION[%02X][%02X]\n", data_rx[0], data_rx[1]);
   
    ESP_ERROR_CHECK(i2c_register_read(FT_ID_G_THGROUP, data_rx, 1));

    printf("FT_ID_G_THGROUP[%02X]\n", data_rx[0]);

    ESP_ERROR_CHECK(i2c_register_read(FT_ID_G_PERIODACTIVE, data_rx, 1));

    printf("FT_ID_G_PERIODACTIVE[%02X]\n", data_rx[0]);    
}

void app_main(void)
{
    static lv_disp_draw_buf_t disp_buf; // contains internal graphic buffer(s) called draw buffer(s)
    static lv_disp_drv_t disp_drv;      // contains callback functions

#if CONFIG_EXAMPLE_AVOID_TEAR_EFFECT_WITH_SEM
    ESP_LOGI(TAG, "Create semaphores");
    sem_vsync_end = xSemaphoreCreateBinary();
    assert(sem_vsync_end);
    sem_gui_ready = xSemaphoreCreateBinary();
    assert(sem_gui_ready);
#endif

#if EXAMPLE_PIN_NUM_BK_LIGHT >= 0
    ESP_LOGI(TAG, "Turn off LCD backlight");
    gpio_config_t bk_gpio_config = {
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = 1ULL << EXAMPLE_PIN_NUM_BK_LIGHT
    };
    ESP_ERROR_CHECK(gpio_config(&bk_gpio_config));
#endif

    ESP_LOGI(TAG, "Install RGB LCD panel driver");
    
    esp_lcd_rgb_panel_config_t panel_config = {
        .data_width = 16, // RGB565 in parallel mode, thus 16bit in width
        .psram_trans_align = 64,
#if CONFIG_EXAMPLE_USE_BOUNCE_BUFFER
        .bounce_buffer_size_px = 10 * EXAMPLE_LCD_H_RES,
#endif
        .clk_src = LCD_CLK_SRC_DEFAULT,
        .disp_gpio_num = EXAMPLE_PIN_NUM_DISP_EN,
        .pclk_gpio_num = EXAMPLE_PIN_NUM_PCLK,
        .vsync_gpio_num = EXAMPLE_PIN_NUM_VSYNC,
        .hsync_gpio_num = EXAMPLE_PIN_NUM_HSYNC,
        .de_gpio_num = EXAMPLE_PIN_NUM_DE,
        .data_gpio_nums = {
            EXAMPLE_PIN_NUM_DATA0,
            EXAMPLE_PIN_NUM_DATA1,
            EXAMPLE_PIN_NUM_DATA2,
            EXAMPLE_PIN_NUM_DATA3,
            EXAMPLE_PIN_NUM_DATA4,
            EXAMPLE_PIN_NUM_DATA5,
            EXAMPLE_PIN_NUM_DATA6,
            EXAMPLE_PIN_NUM_DATA7,
            EXAMPLE_PIN_NUM_DATA8,
            EXAMPLE_PIN_NUM_DATA9,
            EXAMPLE_PIN_NUM_DATA10,
            EXAMPLE_PIN_NUM_DATA11,
            EXAMPLE_PIN_NUM_DATA12,
            EXAMPLE_PIN_NUM_DATA13,
            EXAMPLE_PIN_NUM_DATA14,
            EXAMPLE_PIN_NUM_DATA15,
        },
        .timings = {
            .pclk_hz = EXAMPLE_LCD_PIXEL_CLOCK_HZ,
            .h_res = EXAMPLE_LCD_H_RES,
            .v_res = EXAMPLE_LCD_V_RES,
            // The following parameters should refer to LCD spec
#if 1            
            .hsync_back_porch = 0,//43
            .hsync_front_porch = 8,
            .hsync_pulse_width = 2,
            .vsync_back_porch = 0, //15
            .vsync_front_porch = 12,//12
            .vsync_pulse_width = 10,//10
            .flags.pclk_active_neg = true,
#else
            .hsync_back_porch = 40,
            .hsync_front_porch = 20,
            .hsync_pulse_width = 1,
            .vsync_back_porch = 8,
            .vsync_front_porch = 4,
            .vsync_pulse_width = 1,
            .flags.pclk_active_neg = true,
#endif
            // .flags.hsync_idle_low = 1,
            // .flags.vsync_idle_low = 1,
            // .flags.pclk_idle_high = 1,
        },
        .flags.fb_in_psram = true, // allocate frame buffer in PSRAM
#if CONFIG_EXAMPLE_DOUBLE_FB
        .flags.double_fb = true,   // allocate double frame buffer
#endif // CONFIG_EXAMPLE_DOUBLE_FB
    };
    ESP_ERROR_CHECK(esp_lcd_new_rgb_panel(&panel_config, &panel_handle));

    ESP_LOGI(TAG, "Register event callbacks");
    esp_lcd_rgb_panel_event_callbacks_t cbs = {
        .on_vsync = example_on_vsync_event,
    };
    ESP_ERROR_CHECK(esp_lcd_rgb_panel_register_event_callbacks(panel_handle, &cbs, &disp_drv));

    ESP_LOGI(TAG, "Initialize RGB LCD panel");
    ESP_ERROR_CHECK(esp_lcd_panel_reset(panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(panel_handle));

#if EXAMPLE_PIN_NUM_BK_LIGHT >= 0
    ESP_LOGI(TAG, "Turn on LCD backlight");
    gpio_set_level(EXAMPLE_PIN_NUM_BK_LIGHT, EXAMPLE_LCD_BK_LIGHT_ON_LEVEL);
#endif

    i2c_master_init();
    _tp_5206_init();




    //lcd_dev();

    _lvgl_init(&disp_buf, &disp_drv);
    while (1) {
  
        vTaskDelay(pdMS_TO_TICKS(10));

        lv_timer_handler();
        _scan_tp();
    }    
      
}


static void example_lvgl_flush_cb_new(int x_start, int y_start, int x_end, int y_end,uint8_t *img_data)
{
    // pass the draw buffer to the driver
    //esp_lcd_panel_draw_bitmap(panel_handle, 10, 0, offsetx2 + 1, offsety2 + 1, img_data);
    esp_lcd_panel_draw_bitmap(panel_handle, x_start, y_start, x_end +1, y_end+1 , img_data);

}



static void _task_show_by_rgb(int x_start, int y_start, int max_x, int max_y,uint8_t color_byte ){
    //img_buf
    memset(img_buf, color_byte, max_x*max_y*2);



    example_lvgl_flush_cb_new(x_start, y_start,x_start + max_x, y_start + max_y, img_buf );

}



static void _test_my(int x, int len, uint8_t color_byte){

    memset(img_buf+x, color_byte, len);
    example_lvgl_flush_cb_new(0, 0,480, 480, img_buf );
}

static void _task_show_rgb(){
    int x_start = 0;
    int y_start = 0;
    int x_end = 0;
    int y_end = 0;

#define MAX_X 480
#define MAX_Y 480

#define TEST_IMG_SIZE (MAX_X * MAX_Y * sizeof(uint16_t))
    uint8_t *img = malloc(TEST_IMG_SIZE); 

    uint8_t color_byte = 0xff;

    memset(img, color_byte, TEST_IMG_SIZE);
    x_end = x_start + MAX_X;
    y_end = y_start + MAX_Y;


    example_lvgl_flush_cb_new(x_start, y_start,x_end, y_end, img );

    if(img) free(img);

}

/**
 * @brief i2c master initialization
 */
esp_err_t i2c_master_init(void)
{
    int i2c_master_port = I2C_MASTER_NUM;

    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };

    i2c_param_config(i2c_master_port, &conf);
    return i2c_driver_install(i2c_master_port, conf.mode, I2C_MASTER_RX_BUF_DISABLE, I2C_MASTER_TX_BUF_DISABLE, 0);
}


static esp_err_t i2c_master_write_slave(i2c_port_t i2c_num, uint8_t *data_wr, size_t size)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR << 1) | WRITE_BIT , ACK_CHECK_EN);
    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);
    return ret;
}

static esp_err_t i2c_master_read_slave(i2c_port_t i2c_num, uint8_t *data_rd, size_t size){
    if (size == 0)
    {
        return ESP_OK;
    }

    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR << 1) | READ_BIT, ACK_CHECK_EN);

    if (size > 1)
    {
        i2c_master_read(cmd, data_rd, size - 1, ACK_VAL);
    }

    i2c_master_read_byte(cmd, data_rd + size - 1, NACK_VAL);
    i2c_master_stop(cmd);
    esp_err_t ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(cmd);

   
    return ret;

}

/**
 * @brief Write a byte to a MPU9250 sensor register
 */
static esp_err_t i2c_register_write_byte(uint8_t reg_addr, uint8_t data)
{
    int ret;
    uint8_t write_buf[2] = {reg_addr, data};

    ret = i2c_master_write_to_device(I2C_MASTER_NUM, ESP_SLAVE_ADDR, write_buf, sizeof(write_buf), I2C_MASTER_TIMEOUT_MS / portTICK_PERIOD_MS);

    return ret;
}

/**
 * @brief Read a sequence of bytes from a MPU9250 sensor registers
 */
static esp_err_t i2c_register_read(uint8_t reg_addr, uint8_t *data, size_t len)
{
    return i2c_master_write_read_device(I2C_MASTER_NUM, ESP_SLAVE_ADDR, &reg_addr, 1, data, len, I2C_MASTER_TIMEOUT_MS / portTICK_PERIOD_MS);
}